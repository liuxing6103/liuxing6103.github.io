---
layout: post
category: "other"
---

html5到来之前，面对较高实时性的需求的时候，伟大的程序员们摸索出一个可行性较高的方法。直到现在，在为socket.io等web实时通信方案解决兼容性的时候，仍然要使用这样的“历史方案”。

#“远古的”web实时通信技术

> 我们时常畅想未来，却很少追忆过去。

我想大部分前端新人，像我这样的实习生菜鸟，大概都是从13年左右开始接触前端以及互联网的。那时候html5风头正盛（当然现在也是热点），各种新技术，包括实时通信技术websocket。

这里不讲新技术，而是带大家回顾历史，关于web实时通信。

在html5到来之前，面对较高实时性的需求的时候，伟大的程序员们摸索出一个可行性较高的方法。直到现在，在为socket.io等web实时通信方案解决兼容性的时候，仍然要使用这样的“历史方案”。

关于技术的名称，大部分资料称为long-polling，或有称为反向Ajax或者comet（服务器推送框架）。

下文称这种技术为long-polling。

阅读本文请参照[示例代码](https://github.com/shaomingquan/long-polling/tree/rebuild)，文章里有部分示例代码，但建议直接访问源代码以便参考。


##概述

long-polling是一种实时通信解决方案，在websocket协议发布之前，long-polling是主要的实时性方案。在webqq中，我们通过对http包的分析依然可以发现long-polling的身影。

long-polling的意思为长轮询，还有一种傻瓜式的实时性方案叫polling，就是不停的发Ajax，这个时间间隙一般不会太短，否则内存或者带宽的压力都太大。long-polling作为polling的进化版是如何改进这个方案的呢？如果您不曾了解请向下看~

下图为polling和long-polling的对比图。
![](http://i3.tietuku.com/70f35a3523cf4800.gif)

##核心原理

long-polling技术依赖Ajax和http长连接（不会立即返回的http连接）的支持。

要实现这点要依赖http长连接。现在从一个请求说起，现在有一个由客户端发出的Ajax http请求，服务器在处理这个请求的时候选择**阻塞**，并且延长请求的超时时间（设置成不超时也是可以的），然后使用EventEmmiter注册一个事件，回调函数就是**解除阻塞**，这时如果有另一个请求emit这个事件，相应的请求便响应。

以上就是大概的思想，有兴趣可以看看我的代码实现。

##具体实现

实现代码，请戳[这里](http://github.com/shaomingquan/long-polling)，并切换到rebuild分支。

所谓的库文件有两个，lp-client.js，lp-server.js，分别是客户端库和服务器库。然后一个群聊的例子在`/tests/multichat`。例子很简单，客户端发送消息，服务器收到消息广播，客户端收取并渲染。代码如下。

客户端：


    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <title></title>
        <script src="../../lp-client.js"></script>
    </head>
    <body>
    <input type="text" placeholder="msg" id="msg"/>
    <input type="button" value="send" id="send"/>
    <ul id="msgContent">

    </ul>
    <script>
        var name = prompt("input your name");
        var lpClient = new LP(3000 ,"localhost");
        var msgContent = document.getElementById("msgContent");
        lpClient.on("serverMsg" ,function(data){
            msgContent.innerHTML = msgContent.innerHTML +
                    "<li><b>"+data.name+"</b>"+data.msg+"</li>"
        })
        document.getElementById("send").onclick = function(){
            var msg = document.getElementById("msg").value;
            msgContent.innerHTML = msgContent.innerHTML +
                    "<li><i>"+name+"</i>"+msg+"</li>"
            lpClient.emit("clientMsg" ,{
                name : name ,
                msg : msg
            })
        }
    </script>
    </body>
    </html>


服务器：

    var lp = require("../../lp-server");

    var lpServer = lp();

    lpServer.on("connection" ,function(sockect){
        console.log("someone join ,now there are new user");
        sockect.on("clientMsg" ,function(data){
            console.log("clientMsg trigger" ,data);
            sockect.broadcast("serverMsg",data);
        });
        sockect.on("disconnect" ,function(){
            console.log("someone leave ,now there someone leave");
        })
    })

    lpServer.listen(3000 ,function(){
        console.log("server listen on port 3000");
    });

例子看起来就很眼熟了，典型的实时群聊程序，形式我参考socket.io设计。

下面是long-polling的内部机制（lp-server.js 和 lp-client.js），先看服务器端库lp-server.js。

首先是几个require。

- http，整个long-polling服务器本身还是http服务器。
- polling，一个延迟res返回的库，用于阻塞响应。
- uuid，生成用户的唯一标识符。
- events，生成一个EventEmitter，用于注册以及触发事件。
- urlencode，url解码。

然后我这里写了三个类，LP，Socket，LP\_http。LP实例生成器是将要导出的，LP\_http是http服务器，Socket是用来通信的套接字对象。

再看预留给前端的接口

- /conn（发起连接） 参数无，返回一个id。在执行new LP()时候调用
- /on（监听一个事件） 参数id，interface。interface是要监听的事件名。延迟返回（当对应事件emited），返回值自定义，格式json。
- /emit（emit一个事件） 参数id，interface，其他数据。其他数据自定义。没有返回值。
- /disconn（断开），参数id。在关闭窗口时调用或者手动编码调用。

下面跟着执行过程看一下运行机理

启动服务器的时候`node server.js`，首先拿到LP的实例。然后**监听connection事件**，这时候会生成http服务器。在lp-server.js:line75，http服务器生成，在每次请求到来的时候提取url中的数据，并对不同请求做了不同的处理，就是判断url。然后listen，服务器开始监听。代码如下。


    this.server = http.createServer(function(req ,res){
        //get url
        var url = req.url.substring(1);
        //method is on or emit or conn or disconn
        var method = url.split("?")[0];
        var paras = getParams(url);
        //get config params and kill
        var interface = paras.interface;
        delete paras.interface;
        var id = paras.id;
        delete paras.id;
        //data params
        var data = paras;

        if(method == "emit"){
            ...
        }else if(method == "on"){
            ...
        }else if(method == "conn"){
            ...
        }else if(method == "disconn"){
            ...
        }else{
            throw new Error("invalid request");
        }
    })


然后启动客户端`node app.js`，访问localhost:3002（同一端口不能跑两个httpServer，所以一会儿涉及跨域问题），在客户端生成LP实例，生成的时候同时跟long-polling服务器产生连接，这时在服务器端会生成一个Socket实例(lp-server.js:line114)，并且**触发connection函数**并将这个实例作为参数传进去，并且这个实例拥有唯一标识符，然后将这个标识符（id）返回给客户端，随后的请求都将用到这个（id）。代码如下。

    //new "socket"
    var currentClient = new Socket();
    currentClient.id = uuid.v1();
    //emit conn event
    ee.emit("connection" ,currentClient);
    //client need the id
    res.end(currentClient.id);

现在在chrome中启动两个客户端（多个也行），这时两个客户端都拥有自己的id。

客户端A监听（on）,服务器会设置一个相应阻塞，阻塞的标识符是pid，注册一个标识符为id和interface的组合的监听（lp-server.js:line111），在回调函数中，会释放这个阻塞（lp-server.js:line112）。这时在chrome的网络查看器可以看到一个状态为pending的请求。代码如下。


     //remind pending 1 day
    res.setTimeout(24*60*60*1000);

    //if on blocking
    var pid = uuid.v1();
    polling.on(pid,res);
    //event triggered that res end
    ee.on([id,interface].join("_"),function(data){
        polling.emit(pid,JSON.stringify(data));
    })

现在客户端B要发送一条消息（emit），在服务器触发一个标识符为id（这个id是之前存在服务器端的A的标识符）和interface的组合的监听。这时设置这个监听的回调就会调用，也就是接触响应阻塞。如下面的代码所示（lp-server.js:line101）。


    ee.emit(id + "_" + interface ,data);
    res.end();

客户端库lp-client.js比较简单，按服务器端的设计封装一层即可。然后导出那个LP对象。客户端库代码在[这里](https://github.com/shaomingquan/long-polling/blob/rebuild/lp-client.js)

整个运行如图所示，图是自己画的有点丑= =。
![](http://i3.tietuku.com/27f018603bad3a47.png)

有几个需要注意的地方。

- 这不是真正的webSocket协议或者tcp套接字，只是http服务，在同一端口无法监听两个http服务器。我暂时将long-polling服务器放在与app服务器不同的端口，所以要允许同主机不同端口http的跨域。代码如下（或者见lp-server.js：line93）
	
    var origin = req.headers.origin;
    var host = req.headers.host;
    if(origin.indexOf(host.split(":")[0]) > 0){
        res.setHeader("Access-Control-Allow-Origin" ,origin);
    }

- 相应超时时间设置，因为要阻塞且不失效，所以要res.setTimeout，超时时间默认为2min，我这里设置成一天。
- 因为要达到监听的效果，所以一个on长请求返回之后要立马开始另一个on长请求，所以要有一个循环发送异步请求的设计，代码如下（或见lp-client.js:line24）。

    callbackOrigin = callback;
    callback = function(res){
        callbackOrigin(res);
        ajaxGet(data ,this.server ,"on" ,callback);
    }.bind(this);
    ajaxGet(data ,this.server ,"on" ,callback);

- 关闭窗口或者刷新的时候要断开连接，注册这个函数的时候要注意保留原有的函数（作为库不要具有破坏性= =）。

##早时“奇怪”的设计

当时看这部分知识草草实现的一个版本，在master分支上，也是为什么新分支叫rebuild= =。

在这个版本中是用tcpSocket替代eventEmitter的。但是我在重构的时候发现eventEmitter更适合，所以不再使用tcpSocket。

##一些设想

这个例子作为编程训练还可以，不过对于实时通信，socket.io已经做得足够好了，它会根据浏览器支持度来切换不同的通信策略。

这个程序或者库的一些问题和构想。

- 跨域方式兼容性不够，或者使用代理服务器的方法更好。
- 目前只支持文字传输。
- 探究ws服务器端底层处理细节，再整合到程序中。
- 接口中的特殊参数名字应该特殊化一些，比如id应该变成__id比较好。
- http.createServer内部代码混乱，使用中间件会好很多。

当然这些也只是作为编程练习了，fighting~

暂且说到这，也可能语言表达能力有限，有些地方没说清楚，欢迎面谈探讨（花名阡雨），也欢迎各种吐槽和指教~

