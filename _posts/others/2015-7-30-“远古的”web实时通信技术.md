---
layout: post
category: "other"
---

html5到来之前，面对较高实时性的需求的时候，伟大的程序员们摸索出一个可行性较高的方法。直到现在，在为socket.io等web实时通信方案解决兼容性的时候，仍然要使用这样的“历史方案”。

#“远古的”web实时通信技术

> html5到来之前，面对较高实时性的需求的时候，伟大的程序员们摸索出一个可行性较高的方法。直到现在，在为socket.io等web实时通信方案解决兼容性的时候，仍然要使用这样的“历史方案”。
> 关于技术的名称，大部分资料称为long-polling，或有称为反向Ajax或者comet（服务器推送框架）。
> 下文称这种技术为long-polling。

##概述

long-polling是一种实时通信解决方案，在websocket协议发布之前，long-polling是主要的实时性方案。在webqq中，我们通过对http包的分析依然可以发现long-polling的身影。

我是在学习websocket的时候发现这种技术。long-polling的意思为长轮询，还有一种傻瓜式的实时性方案叫polling，就是不停的发Ajax，这个时间间隙一般不会太短，否则内存或者带宽的压力都太大。long-polling作为polling的进化版是如何改进这个方案的呢？如果您不曾了解请向下看~

##核心原理

long-polling技术依赖Ajax和http长连接（不会立即返回的http连接）的支持。

要实现这点要依赖http长连接。现在从一个请求说起，现在有一个由客户端发出的Ajax http请求，服务器在处理这个请求的时候选择**阻塞**，并且延长请求的超时时间（设置成不超时也是可以的），然后使用EventEmmiter注册一个事件，回调函数就是**解除阻塞**，这时如果有另一个请求emit这个事件，相应的请求便响应。

以上就是大概的思想，有兴趣可以看看我的代码实现。

##具体实现

示例代码请访问[这里](http://github.com/shaomingquan/long-polling)，并切换到rebuild分支。所谓的库文件有两个，lp-client.js，lp-server.js，分别是客户端库和服务器库。然后一个群聊的例子在`/tests/multichat`。例子很简单，客户端发送消息，服务器收到消息广播，客户端收取并渲染。

例子看起来就很眼熟了，典型的实时群聊程序，形式我参考socket.io设计。先看lp-server.js。

首先是几个require。

- http，整个long-polling服务器本身还是http服务器。
- polling，一个延迟res返回的库，用于阻塞响应。
- uuid，生成用户的唯一标识符。
- events，生成一个EventEmitter，用于注册以及触发事件。

然后我这里写了三个类，LP，Socket，LP\_http。LP实例生成器是将要导出的，LP\_http是http服务器，Socket是用来通信的套接字对象。

再看接口设计

- /conn（发起连接） 参数无，返回一个id
- /on（监听一个事件） 参数id，interface。interface是要监听的事件名。延迟返回（当对应事件emited），返回值自定义，格式json。
- /emit（emit一个事件） 参数id，interface，其他数据。其他数据自定义。没有返回值。
- /disconn（断开），参数id。

启动服务器的时候`node server.js`，首先拿到LP的实例。然后**监听connection事件**，这时候会生成http服务器。在75行，http服务器生成，并对将要发来的不同请求做了不同的处理。然后listen，服务器开始监听。

然后启动客户端`node app.js`，访问localhost:3002（同一端口不能跑两个httpServer，所以一会儿涉及跨域问题），在客户端生成LP实例，生成的时候同时跟long-polling服务器产生连接，这时在服务器端会生成一个Socket实例(lp-server.js:line114)，并且**触发connection函数**并将这个实例作为参数传进去，并且这个实例拥有唯一标识符，然后将这个标识符返回给客户端，随后的请求都将用到。

现在客户端要发送一条消息（emit），在服务器触发一个标识符为id和interface的组合的监听。这时设置这个监听的请求就会返回。监听（on）,服务器会设置一个相应阻塞，注册一个标识符为id和interface的组合的监听，在回调函数中，释放这个阻塞，于是实现了实时的客户端监听。

有几个需要注意的地方。

- 这不是真正的webSocket协议或者tcp套接字，只是http服务，在同一端口无法监听两个http服务器。我暂时将long-polling服务器放在与app服务器不同的端口，所以要允许同主机不同端口http的跨域。见lp-server.js:line92
- 相应超时时间设置，因为要阻塞且不失效，所以要res.setTimeout，我这里设置成一天。
- 因为要达到监听的效果，所以一个on长请求返回之后要立马开始另一个on长请求，所以要有一个循环发送异步请求的设计，见lp-client.js:line24。
- 关闭窗口或者刷新的时候要断开连接，注册这个函数的时候要注意保留原有的函数（作为库不要具有破坏性= =）。

##早时“奇怪”的设计

当时看这部分知识草草实现的一个版本，在master分支上，也是为什么新分支叫rebuild= =。

在这个版本中是用tcpSocket替代eventEmitter的。但是我在重构的时候发现eventEmitter更适合，所以不再使用tcpSocket。

##一些设想

这个例子作为编程训练还可以，不过对于实时通信，socket.io已经做得足够好了，它会根据浏览器支持度来切换不同的通信策略。

作为编程训练，我想在给这个库添加流信息的传送功能，如果探究websocket协议内容的时候可以整合一下两者功能，还有字符编码的问题，另外代码还是显得难看还需重构。

暂且说到这，欢迎各种吐槽和指教~

