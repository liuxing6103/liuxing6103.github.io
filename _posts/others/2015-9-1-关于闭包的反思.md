---
layout: post
category: "other"
---

闭包是好是坏？

#关于闭包的一些思考

至于闭包是什么，听起来可能很抽象，其实js写得多的人都心知肚明，其实就是沿着词法作用域链向上查找当前作用域所用到的变量。合理使用闭包会使工作事半功倍，但不合理的使用却会使程序的质量大大下降。

##首先对比闭包和非闭包代码的执行效率

一个测时间的函数

	module.exports = function(func){

  		var funcName = func.name;

  		var startTime = new Date().valueOf();
  		func();
  		var endTime = new Date().valueOf();

  		console.log(funcName+ "->" + (endTime - startTime) + "ms");
	}



两个函数，功能只是循环，并传入到time函数中测试执行时间。


    var time = require("./time");

    //with clourse

    function addWithoutClosure(){

      var a = 0;
      return (function(a){

        for(var i = 0 ; i < 1000000000 ; i++){
          a ++;
        }

        return a;

      })(a)

    }

    function addWithClosure(){

      var a = 0;
      return (function(){

        for(var i = 0; i < 1000000000 ;i++){
          a++;
        }

        return a ;

      })()

    }

    time(addWithClourse)
    time(addWithoutClourse)



执行结果

![](http://i1.tietuku.com/90fcc9013e94b356.png)

回想闭包实现原理，以及实验结果，我们可以得出结论：闭包确实会影响js的运行效率。

所以说不要使用闭包，除非你需要它。

同闭包的作用域查询一样，原型链查询也是需要成本的。这里也做了个小实验。

##一些使用闭包的场景

###受保护的变量

    fucntion protect(){
    	var protected = 0;
    	return function cannotLtZero(number){
    		if(number < 0){
    			return false;
    		}else{
    			protected = number;
    			return true;
    		}
    	}
    }

###多个异步函数监控一个变量

    var number = 0;
    down.onclick = function(){
    	number --;
    }
    up.onclick = function(){
    	number ++;
    }

###以及很多业务场景

大概大家写闭包都很自然了，很少会意识到有些时候有时候关键节点的闭包实现，导致的查询作用域的成本是巨大的。

##面向对象会不会是一种折中？

做一下实验。。

    function ADD(){

      this.a = 0;
      this.add = function addWithClass(){
        for(var i = 0 ; i< 10000000 ; i++){
          this.a ++;
        }
      }

    }

    var add = new ADD();

    (function(){

      var funcName = add.add.name;

      var startTime = new Date().valueOf();
      add.add();
      var endTime = new Date().valueOf();

      console.log(funcName+ "->" + (endTime - startTime) + "ms");
    })()

实验结果是20ms左右要比闭包法快，还是没有非闭包的方法快。

所以js的面向对象方法还是有一定的好处的。

##问题来了

###闭包是某些场景的硬性需求吗？

比如这个。貌似闭包的效果比所谓面向对象还要好（排除es5中的setter），因为只有你抛出来的函数才能访问变量，你可以对访问的尺度把关。

    fucntion protect(){
    	var protected = 0;
    	return function cannotLtZero(number){
    		if(number < 0){
    			return false;
    		}else{
    			protected = number;
    			return true;
    		}
    	}
    }

我想了一阵子，我的答案可能是必要的。毕竟栈中的变量确实依赖于下层作用域引用才得以保存，即使基本变量通过bind方法传进来，也无济于事，因为传进来的只是一个值，而不是引用。

###既然是必要的，那么什么是不好的写法呢？

我想可能很多人包括我写js的时候有时候懒得传参数就写成闭包。而且觉得。就像我开始举的例子，闭包折损了效率。

比如我们可能经常会这样：

```
var a = 0;
function b(){
	return a + 1;
}
b();
```

那么这样写呢？效率就或多或少的增加一些。而且从函数的意义上这样更清晰。不过代码增加了。

```
var a = 0;
function b(a){
	return a + 1;
}
b(a);
```

闭包写起来浪，帅，知道查作用域了，却忘了这个成本。

###之前的想法

天真的以为我通过语法分析毙掉所有的闭包就可以改革js运行效率，现在看来没有想象的那么简单，因为有时候闭包是被需要的。所以可能不能毙掉所有的闭包。

###强类型javascript编译语言

javascript本身看起来简单，实际上很难写出完美的代码，所以一些伟大的工程师搞出了如coffee，typescript，dart之类的来约束编译后的js规范。大概是这样的，具体这些的特性与优势，再探讨吧。

##还是想做一些实验

- [esprima](http://esprima.org/)

这时一个js语法分析的库。我发现如果函数被赋值或者被return，这时闭包可能具有实际意义，所以我们可以大概的分辨什么事有意义的闭包，什么是无意义的闭包。

所以是不是找到无用的闭包然后通过esprima库改造成效率较高的非闭包模式，或许可以提高代码的效率。

这个实验作为一个大专题来做吧，关于javascript代码效率问题，除了闭包还有很多可讨论的主题，比如一大串var，和var一次哪个效率更高？dom树构建顺序，从下往上效率更高。

可能从前端角度，更熟悉的性质是dom，如果说node的话，可能情况还会不一样。所以如果说把javascript代码优化做成一个东西的话，可能要出现一些分支，譬如针对dom，针对node。

所以今天算是调研了，引出一个主题，待我随后开展。

