---
layout: post
category: "other"
---

数据库设计，再看mongodb这个典型的文档型数据库，想想自己关系型数据库快忘了，回头复习一下，毕竟很少这么有用的科目。写给自己复习的，要是真有别人看的话我希望你有这方面基础和经验，当然欢迎高手各种指正。

#数据库设计基础

对比学习关系型数据库和文档型数据库。选用典型的mongodb和MySQL。

想必大多数人听说mongodb的时候，mongo是以菲关系型数据库的身份出现的。其实不确切，因为光非关系型数据库就分

下面是NoSQL的分类表，摘自[这里](http://www.csdn.net/article/2012-05-15/2805586)。这个文章不错，不过我对于这个文章现在的理解很有限，我这里只限于应用级开发的干货。

- Key-Value 存储: Oracle Coherence, Redis, Kyoto Cabinet
- 类BigTable存储: Apache HBase, Apache Cassandra
- 文档数据库: MongoDB, CouchDB
- 全文索引: Apache Lucene, Apache Solr
- 图数据库: neo4j, FlockDB

这么多东西，反正只要找到官网读他们的宣传都会觉得这东西碉堡了，仁者见仁智者见智吧，还是要累积开发经验多做横评，选出合适的东西。反正我熟悉的就是redis和mongodb，其他的一概没听说过= =。redis强项是缓存设计，mongodb功能相比redis复杂一些，相对关系型数据库又很灵活轻量，适合小型应用和分布式系统。

##关系型数据库设计

只限应用级，我对这些的理解与专业搞数据库的差太多太多。我把之前上课的书（见下图）翻出来了，就对照着这个看了（再次看到大学那个数据库真是恍如昨日）。上课时用的是SqlServer 2008（学校也是醉，什么2008，ie7，WinXP）。

![](http://f.hiphotos.baidu.com/baike/g%3D0%3Bw%3D268/sign=97f83f89a40f4bfb9cd09b5f74724ac6/2fdda3cc7cd98d1014135c27213fb80e7aec90e4.jpg)

关系型数据库有一套强大的理论基础支持着，E-R模式，第三范式，关系代数，从设计到应用，有明确的基础理论支持，这些是关系型数据库通用的模式，对已不同的关系型数据库细节上可能会有不同，比如SqlServer不支持自然连接。所以说不同关系型数据库之间存在少量非本质的横评。

下面先介绍基础，在谈设计，然后使用。

###基础

####数据库系统的目标

最开始没有数据库系统之前，单位使用文件来存储信息，这是一种策略，但是各种缺点啊（page2）。而数据库系统的目标就是改变这些东西，所以说文件系统的缺点也体现数据库系统的目标。我这里言简意赅的说明。

- 数据冗余和不一致：多对多怎么存？因为各个文件之间无法像关系型数据库那样join，所以有些数据要存很多次。
- 访问困难：以最初的需求定制的文件规范，无法应对多变的需求。
- 数据孤立：数据在不同的文件，文件有不同的格式（怎么理解？也许如果跨平台了，来自不同平台的文件可能访问方法不一样？）
- 完整性问题：对于数据的约束，使用文件只能从程序入手，难以维护，无法像数据库那样自如。
- 原子性问题：我的理解是一套业务的各个子操作是绑定的，要么都发生，业务完毕，要是有一项子操作失败，退回初始状态。传统的文件系统很难做到，关于数据库系统的原子性保障后续提。
- 并发访问异常：两个用户同时访问这个数据时，不会累积其中一个用户对另一个用户的影响。也就是其中一个操作还未写入更新，另一个便读数据，所以并未读到更新之后的数据。
- 安全性问题：文件系统权限太单一，数据库系统对于数据的权限更丰富，保障分工，自己处理自己的数据。

####数据抽象的三层

- 物理层：不是硬件的那种物理，是底层的数据结构，算法。比如MySQL中运用了红黑树。
- 逻辑层：就是数据库设计，就是告诉物理层，我存的就是这些表。
- 视图层：安全性的一个体现，给不同人发放不同的功能，越权操作不可能。视图层配置（视图以及用户）是dba的事情，视图层的使用是类似服务器程序员那群人。

####实例和模式

就是对象和类的关系。

####数据模型

简单的说。

- 关系模型：是用来存数据的那个表的形式，列是属性，行是实体，连接了各个属性的关系，也就是联系了各个数据。这一切都是可以看见的东西。
- 实体联系模型：传说中的E-R模型，用来数据库设计，生成对应的关系模型之后就不再使用。
- 基于对象的数据模型：sql有继承的机制，属于高阶主题，暂不介绍。

####数据库操纵语言

最广泛的数据库操纵语言是sql，一会儿详说。

####实体关系模型

数据库设计的根本，一般使用UML进行建模，一会儿详说。

####码

这之前有些很基础的东西，作者放在体系里。我这里不说了。码这个地方挺关键的肯定要理解的。

- 超码：可以是一个属性，可以使多个属性的组合，甚至整个实体。
- 候选码：任意子集都不是超码的超码，也就是最小超码。
- 主码：上升到工程上，而不是理论。根据项目需求选出的候选码。
- 外码：是另一个模式中的主码，一种参照关系。

###设计

通过E-R模型，建立整个数据库。

从这个大学E-R图入手，这教材中完整的例子。

![](http://i1.tietuku.com/d2c81a1927d32be7.jpg)

各种线框的感觉会很晕。慢慢来看。

矩形框是实体，上面深背景的部分是表名称，下面是属性，下划线标注的是主码，菱形框是关系。然后会有许多的线将这些实体通过关系串联起来。

- 首先看中间的advisor，这个是多对一的关系，表示一个导师可以带多个学生。注意到类似的像inst_dept，stud_dept，sec_time_slot这些也是一对多的关系，区别是使用双线，表示全部参与的意思，一个教师必须有一个系对应。而刚刚入学的学生可能还没有导师，所以不是全部参与，故用单线。

- 再看teaches（advisor左下方）。这是个多对多的关系，一门课可以有多个老师教，一个老师也可以教授多门课，老师可以在这学期不授课（大学会有，有时候院长高兴了教门课也说不上，不过院长大部分时间在带博士生，一般不授课），但是课不可无老师教授，所以课程在关系中全部参与。

- 哦这里没有一对一的，用双单箭头表示。都一对一了，就谈不上参与不参与了，就比如你跟你女（男）朋友（是我太保守了么= =），这就是一对一 ，你 <-- 爱 --> 你女朋友。好的下面还接着看图。

- 图的有边有个与grade用虚线链接的grade，是这样的，有时候联系可能比较复杂，需要联系集属性，这个虚线连接的就是一些联系集属性，比如这个是学生上这个课所得的分数。

- 左下角有个叫prereq的关系，是预先课程，就像高校培养方案那个表。用正规的话叫角色。所谓的角色是在同一个实体集里各个实体之间的关系，就像这里，谁是谁的precourse。

- 最后是那个最不和谐的双框菱形。这个涉及到弱实体集，section就是一个弱实体集，它要与一个属主实体集联系才有意义，弱实体集没有自己的主键，它具有分辨符，用下虚线标记。弱实体集的主键是它属主实体集的主键加它的分辨符。

大概主要的关系就是上面这些，可以感觉，细致的分析用户需求和产品文档是E-R模型建模的关键。顺利建好之后就可以转化成关系模式了，也就是转成表。

上面那个图里面有三种东西，强实体集，弱实体集，联系集。书接下来就讲了这些个东西的关系模式表达法。原则上跟他们的角色，参与度，映射关系有关。

- 强实体集只需注意明确主键。
- 弱实体集要注意主键是它的分辨符加上它所依赖的那个实体集的主键。
- 联系集属性一般是两边的交集。选择联系集的主键是要根据映射基数和参与度等情况
	- 对于多对多的二元联系，参与实体集的主码属性的并集为主码。
	- 对于一对一的二元属性，任何一个实体集的主码都可以选作主码。
	- 对于多对一或者一对多的二元联系集，联系集正多的那一方的实体集的主码构成主码。
- 强实体集和弱实体集的联系集不需要列出来。
- 最后这一个不是罗列，这个以前罗列已经完成，这个是优化这个罗列，减少冗余。有以下几个原则。
	- 对于A到B的一个一对多的联系集AB，若A全部参与，则A和AB合并。比如inst_dept和instructor就可以合并。
	- 对于一对一，可以和任何一个合并。

从上面的步骤来看是先罗列再合并。

还有一些问题，比如新增的属性是要加在属性里还是要增加新的模式，一个对象是表示成实体集还是联系集，是二元联系集还是三元联系集。这些就不细说了，怎么理解跟生活常识有关系。比如要给instructor加一个phoneNumber，由于不一定有哟个电话号码所以最好新增一个模式。这些问题暂且跳过在书的163页的7.7小节。

经过之前的折腾之后我们获得大学数据库的关系模式。如下图。

![](http://i1.tietuku.com/3612f1b97ffeb592.jpg)

作为一个数据库上面的模式已经够用。不过精确的理论方法涉及到各种范式。

关于范式请看我这里的[关系型数据库范式说明](http://baidu.com)。

第一范式，没有重复的列。

第二范式，两点，第一必须有主码。第二全部依赖，与全部依赖对立的是部分依赖，也就是说不能存在部分依赖，看下面例子。

以学生选课为例，每个学生都可以选课，并且有这一门课程的成绩，那么如果将这些信息都放在一张表`StuGrade(stuNo,stuName,age,sex,courseNo,courseName,credit,score)`。如果不仔细看，我们会以为这张表的主键是`stuNo`，但是当我们看到最后一个`score`属性以后，在想想如果没有课程信息，那么哪里有学生成绩信息呢。所以这张表的主键是一个**联合主键**`(stuNo,corseNo)`，这个联合属性能够唯一确定score属性。那么再看其他信息，比如stuName只需要stuNo就能够唯一确定，courseName只需要courseNo就能够唯一确定，因此这样就**存在了部分依赖**，不符合第二范式。如果要让学生课程成绩信息满足第二范式，那么久需要将这张表拆分成多张表，一张学生表Studnet(stuNo,stuName,age,sex)，一张课程表Course(courseNo,courseName,credit)，还有最后一张学生课程成绩表StuGrade(stuNo,courseNo,score)。这样就符合第二范式了。

BC范式和第三范式都是消除传递依赖，消除传递依赖见下面例子。

每一个员工都有一个所属部门，假如有一个员工信息表`Employee(emp_id,emp_name,emp_age,dept_id,dept_name,dept_info)`。这张员工信息表的属性是`emp_id`，因为这个属性能够唯一确定其他所有属性，比如知道员工编号`emp_id`以后，肯定能够知道员工姓名，所属部门编号，部门名称和部门介绍。所以这里dept_id **不是主属性，而是非主属性** 。但是，我们又可以发现`dept_name,dept_info`这两个属性也 **可以由dept_id这个非主属性决定** ，即`dept_name`依赖`dept_id`，而`dept_id`依赖`emp_id`，这样就 **存在了传递依赖** 。而且我们可以看出传递依赖的一个明显缺点就是 **数据冗余非常严重** 。那么如何解决传递依赖问题，其实非常简单，我们只需要将`dept_name,dept_info`这连个属性删除就可以了，即`Employee(emp_id,emp_name,emp_age,dept_id)`，然后再创建一个部门表`Dept(dept_id,dept_name,dept_info)`。这样如果要搜索某一个员工的部门信息`dept_info`，可以通过数据库连接来实现，查询语句如下：
`select e.emp_id,e.emp_name,d.dept_name from Employee e,Dept d where e.dept_id=d.dept_id`。

BC范式，学名Boyce-Codd范式（英语：Boyce-Codd normal form，缩写BCNF），是数据库规范化中所使用的一种正规形式。是在第三范式的基础上加上更严格约束，每个BCNF关系是第三范式的子集，有从属关系。

对于一个模式R中的所有非平凡函数依赖a -> b，只要共同满足a是R一个超码，有一组不符合就不行。

第三范式，第三范式相对BC范式宽松一些，a可以不是R的一个超超码，但是如果这样就必须满足b - a中的每个属性a都包含于R的一个候选码中。看下面满足第三范式但不满足BC范式的例子。

在大学数据库ER图未合并之前中一个模式dept_advisor。`dept_advisor(s_ID ,i_ID ,dept_name)`。假定附加约束，一个教师只能在一个系担任老师。那么有依赖s_ID -> dept_name，s_ID ,dept_name -> i_ID，s_ID不是超码，所以不满足BC范式。但是dept_name - s_ID = dept_name 包含于候选码，所以属于第三范式。

###使用

这里的使用暂时之涉及sql语言。

##文档型数据库

###设计

文档型数据库只是nosql中的一种，这里看了一下mongodb中的模式设计。

去官网看了文档，然后看了[这个视频](https://www.mongodb.com/presentations/webinar-back-basics-1-thinking-documents?jmp=docs&_ga=1.176760877.900011625.1426734064)。英文视频虽然看的稀里糊涂，还是感觉收益了。

最重要的是reference和embeded这两个概念。

reference：

![](http://docs.mongodb.org/manual/_images/data-model-normalized.png)

embeded：

![](http://docs.mongodb.org/manual/_images/data-model-denormalized.png)

一对一，一对多或者多对一，用embedded。多对多用reference。

###使用

####命令行的使用

内容比较多，我从网上摘了一段，总结的比较详细，看[这里](http://www.cnblogs.com/xusir/archive/2012/12/24/2830957.html)。

####编程中使用

还是用我最擅长的node吧，有主流的有两种，现在打开亲爱的npmjs.com。有两个库，第一个是mongodb这个属于官方的未经封装的，第二个mongoose。

