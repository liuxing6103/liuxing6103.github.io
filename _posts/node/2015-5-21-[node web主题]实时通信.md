---
layout: post
category: "node"
---
socke是什么？一句话，socket是对TCP/IP协议的封装和应用。这是从程序员角度出发的。可以说socket是TCP的一套接口，至于更加底层的研究，超出了我的能力范围。对于这一套接口的使用，根据语言特性的不同，接口的使用方法也大相径庭。

#[node web主题]实时通信

> 从原生socket到websocket。


比如c语言中的socket服务器，如果支持多链接的话，就必须使用fork等函数开子进程。node socket则通过闭包管理各个socket链接，作为更顶层的平台node中使用socket要比c简单的多。

##node中的原生socket

使用node平台的原生库net的createServer方法便可以构建一个TCP服务器，然后就可以使用socket进行通信。

步骤大概这样，先创建一个TCP服务器，然后各种监听，像listening，close，error，connection，error事件的回调中会传入错误信息，connection回调中会传入跟客户端的链接凭据socket，我们可以将这个标识保存在一个数组里，以备后续使用。最后别忘了将tcp服务器挂在一个端口上面。

然后就是可以进行链接，链接之后返回的对象可以向服务其发送数据也可以监听数据的返回。

tcp服务器实例。

	//tcp server
	var server = require("net").createServer();
	
	server.on('listening' ,function(){
		console.log('server is listening on port ' ,3000);
	});
	
	server.on('connection' ,function(socket){
		console.log('server has a new connection');
		socket.on('data',function(data){
			console.log(data.toString());
			socket.write(data + " too");
		});
	
		socket.on('end',function(data){
			console.log('client connection ___________________')
		});	
	});
	
	server.on('close' ,function(){
		console.log('server is now closed');
	});
	
	server.on('error' ,function(err){
		console.log('error occurred:' ,err.message);
	});
	
	server.listen(3000);

tcp客户端例子（一次链接）

	// tcp client
	
	var net = require("net");
	
	var port = "3000";
	
	var host = "localhost";
	
	var conn = net.createConnection(port ,host ,connectListener)
	
	function connectListener(){
		console.log("got connected!");
	}
	
	conn.write("I love you");
	
	conn.on("data" ,function(data){
		console.log(data.toString());
	})

事先运行server之后再运行client。运行结果如下（今天是521，配合气氛的输入）。

![](http://i1.tietuku.com/3a28ef1e761fd5e2.png)

再来一个多人聊天的例子。

服务器代码。

	var net = require('net');
	
	var server = net.createServer();
	
	var sockets = [];
	
	server.on('connection',function(socket){
		sockets.push(socket);
		socket.write('you just join an meeting');
		socket.on('data',function(data){
			sockets.forEach(function(currentSocket){
				if(socket !== currentSocket){
					currentSocket.write(data);
				}
			});
		});
		
		socket.on('close',function(){
			var index = sockets.indexOf(socket);
			sockets.splice(index ,1);
		});
	});
	
	server.on('close',function(){
		sockets.forEach(function(currentSocket){
			currentSocket.write('server is closed ,bye');		
		});
	});
	
	server.listen(3000);

客户端代码（win下面我用telnet连接失败）

	var net = require("net");
	
	var port = "3000";
	
	var host = "localhost";
	
	var conn = net.createConnection(port ,host ,function(){
		console.log("listening...");
	});
	
	conn.on("data" ,function(data){
		console.log(data.toString());
	})
	
	process.stdin.on("data" ,function(data){
		conn.write(data);
	})

##上古的实时应用

###轮询

就是用Ajax不停的问服务器：有没有新的消息呀？服务器可能会有消息更新，或者没有。适合实时性不高的应用，比如微博。优点是后台代码比较简单，兼容性好，但无用流量太大。这个比较简单，以前也很不幸写过类似的东西- -。这里就不上例子了。

###长轮询

是comet（基于 HTTP 长连接的“服务器推”技术）的一种解决方案或者称为反向Ajax。客户端代码跟普通的轮询是一样的，不过可以进行递归请求，这样也不能影响任何，原因是服务器将http请求延迟响应，当服务器端有更新的时候再进行响应。这实际上是利用了服务器端的实时性（服务器端TCP socket），有点将客户端服务器的实时过渡到服务器的实时性的感觉。就像下图。下面可以实现一下这个效果。

![](http://s7.51cto.com/wyfs02/M01/22/A4/wKiom1MilrnS4D8lAABmg6aj1wg514.jpg)

node里面有个polling库，例子如下。

服务器

	var http = require('http');
	var fs=require('fs');
	var polling= require('polling');
	
	http.createServer(function (req, res) {
	  if (req.url === '/') {
	    var rs = fs.createReadStream('./index.html' + req.url);
	      rs.on('error', function (err) {
	      res.end('Request Error: ' + err.code + ' when request: ' + req.url);
	    });
	    rs.pipe(res);
	  }else{
	    polling.on('testmsg',res);
	  }
	}).listen(3000);
	
	setInterval(function () {
	  polling.emit('testmsg',new Date().toString());
	},1000);

客户端代码如下。

	<!DOCTYPE html>
	<html>
	<head>
	    <title>polling test</title>
	</head>
	<body>
	<h1>polling test</h1>
	
	<p>Welcome use polling, here will shown the message of server.</p>
	
	<div id="myDiv"></div>
	</body>
	<script>
	        var req = new XMLHttpRequest();
	        req.onreadystatechange = function () {
	            if (req.readyState == 4) {
	                if (req.status == 200) {
	                    document.getElementById("myDiv").innerHTML += req.responseText + '<br>';
	                }
	                getMsg();
	            }
	        }
	        getMsg();
	
	        function getMsg() {
	            req.open("GET", "http://localhost:3000/getMsg", true);
	            req.send();
	        }
	</script>
	</html>

递归发送请求，但是由于服务器的响应挂起，结果1000之后才传过来。

既然人家大神都实现了，我就来分析一下吧。

送上源码[传送门](https://github.com/ngtmuzi/polling/blob/master/index.js)。不会有很多行，也不依赖其他库。

line4：一个全局对象。通过后续的代码可以得知，储存键为ID，值为res数组。可见每个ID可以注册多个res，可以一并emit。

line12：on函数给ID注册res。

line13：这里有一个判断，我打印了一下res.socket这个对象，很长的一大串，看起来并不知道有什么卵用。但是在res.end()之后这个对象就被delete了，也就是打印的结果是null。好像明白了什么。其实就是说，如果你已经end了，就不要来凑热闹了好吧！

line29：emit函数，触发某ID中的所有res，并且携带信息。

line30：注意到这里有一个process.nextTick，意味着emit其实真正的函数内容是要在同步代码执行结束后之后第一个执行的异步函数。也就意味着emit和on的书写顺序不会影响函数的执行。

line33：还有一个判断，因为不排除在on和emit之间会有res end掉。

line48：注销一个ID。

line60：清除那些已经没有可end的res的ID。

line76：暴露接口。

下面用这个lib写一个多人聊天服务器。

又到了贴代码的时间（这个东西写了挺长时间，中间改了一下）。

写的有点粗暴，我简单讲解一下思想。

首先有一个tcp的广播服务器。在访问“/”的时候为客户保存一个tcp客户端连接，这个连接连接到刚刚的广播服务器上，同时保存tcp服务器的套接字，生成一个id对应到这个连接上，并且打印到前台（这里做了一个简单的字符串替换操作，来完成打印这个动作）。

随即前端发送Ajax get到/getMsg，并携带连接的ID，polling用这个ID注册这个res，得到对应ID的连接，并监听data事件，事件触发则emit这个ID。

当发送输入的信息的时候，前端发送Ajax get到/sendMsg，携带姓名，内容，连接的ID，服务器拿到这些数据后使用ID拿到这个connection，发送这个数据到tcp服务器，tcp服务器广播，直接导致polling emit。然后前端返回，并进行下一轮getMsg。

这里值得注意的地方是，将响应超时时间设置成一个比较大的值（node原生服务器res的超时时间是2min）。

服务器代码。

	// long-polling.js
	
	//tcp server 
	var net = require("net");
	
	var tcpServer = net.createServer();
	
	var sockets = [];
	
	tcpServer.on("connection" ,function(socket){
	
		sockets.push(socket);
	
		console.log("join... now there is ",sockets.length ," client");
	
		socket.on("data" ,function(data){
	
			sockets.forEach(function(currentSocket){
				if(socket != currentSocket){
					currentSocket.write(data);
				}
			})
	
		});
	
		socket.on("close" ,function(){
			var index = sockets.indexOf(socket);
			sockets.splice(index ,1);
			console.log("disconnect... now there is ",sockets.length ," client");
		})
	
	})
	
	tcpServer.listen(3001);
	
	
	//http server
	
	var polling = require("polling");
	
	var uuid = require("uuid");
	
	var fs = require("fs");
	
	var conns = {};
	
	var httpServer = require("http").createServer(function(req ,res){
	
		var url,ID,conn;
	
		url = req.url;
	
		if(url == "/"){
	
	
			ID = uuid.v1();
	
			conn = net.createConnection("3001" ,"localhost");
	
			conns[ID] = conn;
	
			fs.readFile(__dirname + "/polling.html" ,function(err ,data){
				data = data.toString();
				res.end(data.replace("XXXXX" ,ID));
			})
	
		}else if(url.indexOf("/getMsg") >= 0){
	
			var ID = getParams(url).ID;
	
			res.setTimeout(60*60*1000);
	
			polling.on(ID ,res);
			
			conns[ID].on("data" ,function(data){
				polling.emit(ID,data);
			})
		}else if(url.indexOf("/sendMsg") >= 0){
	
			var params = getParams(url);
	
			ID = params["ID"];
	
			delete params.ID;
	
			params = JSON.stringify(params);
	
			conns[ID].write(params);
	
			res.end();
	
		}else if(url.indexOf("/kill") >= 0){
			ID = getParams(url).ID;
	
			conns[ID].end();
	
			delete conns[ID];
	
			res.end();
		}else{
			res.end("no that resource");
		}
	
	});
	
	function getParams(url){
		var qs = url.split("?")[1];
		var pms = qs.split("&");
		var pmLength = pms.length;
		var currentPm = []
		var result = {};
		for(var i = 0; i < pmLength ; i++){
			currentPm = pms[i].split("=");
			result[currentPm[0]] = currentPm[1];
		}
		return result;
	}
	
	httpServer.listen(3000);



客户端代码。

	<!-- polling.html -->
	
	<!DOCTYPE html>
	<html>
	<head>
		<meta charset="utf-8">
		<meta http-equiv="X-UA-Compatible" content="IE=edge">
		<title></title>
		<link rel="stylesheet" href="">
	</head>
	<body>
		<form action="" id="form">
			<input type="hidden" id="ID" value="XXXXX">
			<input type="text" id="msg">
		</form>
		<ul id="msgList">
			
		</ul>
		<script>
	
			var name = prompt("what is your name?");
	
			var $ = document.getElementById;
			var form = $.call(document ,"form");
			var msg = $.call(document ,"msg");
			var msgList = $.call(document ,"msgList");
	
			var connId = $.call(document ,"ID").value;
	
			var render = renderIt("msgList");
	
			ajaxGetMsg();
	
			ajaxSendMsg();
	
			killConn();
	
			function ajaxSendMsg(){
	
				form.onsubmit = function(){
	
					var req = new XMLHttpRequest();
					req.open("GET", "http://localhost:3000/sendMsg?name="+name+"&content="+msg.value + "&ID=" + connId, true);
		            req.send();
	
		            render({
		            	name : name ,
		            	content : msg.value
		            });
	
					return false;
	
				}
	
			}
	
			function ajaxGetMsg(){
	
				var req = new XMLHttpRequest();
		        req.onreadystatechange = function () {
		            if (req.readyState == 4) {
		                if (req.status == 200) {
		                	render(eval("("+req.responseText+")"));
		                	ajaxGetMsg();
		                }
		            }
		        }
	
	            req.open("GET", "http://localhost:3000/getMsg?ID=" + connId);
	            req.send();
	
			}
	
			function killConn(){
				window.onbeforeunload = function(){
					var req = new XMLHttpRequest();
					req.open("GET", "http://localhost:3000/kill?ID=" + connId ,false);
					req.send();
				}
			}
	
			function renderIt(ul){
				var ul = document.getElementById(ul);
				return function(data){
					var nameContent = document.createElement("b");
					var contentContent = document.createElement("span");
					var li = document.createElement("li");
	
					var name = document.createTextNode(data.name);
					var content = document.createTextNode("："+data.content);
	
					nameContent.appendChild(name);
					contentContent.appendChild(content);
	
					li.appendChild(nameContent);
					li.appendChild(contentContent);
	
					ul.appendChild(li);
				}
			}
	
		</script>
	</body>
	</html>

###长连接

实际上也是一种comet技术，使用iframe代替Ajax。这应该是一种古老的做法。有点搞不懂，什么keep-alive，现在一般服务器不都是keep-alive吗？我觉得这是对Ajax的一种兼容，可是现在Ajax已经成为常规技术了，当然websocket并未成为常规技术，所以长轮训还是有一定的用武之地的。

##websocket

websocket的实时性更高，十年前Ajax给web带来无限可能，今天，websocket使web成为日渐完善的客户端。实时聊天，随着各种游戏库在web端的实现，实时web网络游戏也变得火起来，不在依托Flash。

###socket.io实现

写起来相当飘逸，感受一下。前后端几乎对等的写法，注册和发射分配在不同端，注册监听数据，发射写入数据。

server代码

	var app = require("http").createServer(handler);
	
	var io = require("socket.io")();
	
	var fs = require("fs");
	
	app.listen(3000);
	
	function handler(req ,res){
	
		fs.readFile(__dirname + "/index.html" ,function(err ,data){
			if(err){
				res.writeHead(500);
				return res.end("Error loading index.html");
			}
			res.writeHead(200);
			res.end(data);
		});
	
	}
	
	io.on("connection" ,function(socket){
		socket.emit("news" ,{hello : "world"});
		socket.on("my other event" ,function(data){
			console.log(data);
		});
	})
	
	io.listen(3001);

client代码

	<!-- index.html -->
	<!DOCTYPE html>
	<html>
	<head>
		<meta charset="utf-8">
		<meta http-equiv="X-UA-Compatible" content="IE=edge">
		<title>socket</title>
		<script src="https://cdn.socket.io/socket.io-1.3.5.js"></script>
		<script>
			var socket = io("http://localhost:3001")
			socket.on("news" ,function(data){
				console.log(data);
				socket.emit("my other event" ,{my : "data"});
			})
		</script>
		<link rel="stylesheet" href="">
	</head>
	<body>
	</body>
	</html>

io对象可以自定端口，也可以使用web服务器的端口，我想分开来这样会不会降低服务器的一些压力？实时通信服务器与web服务器使用相同的端口的写法如下。

	...
	...
	var io = require("socket.io")(app);
	...
	...
	<del>io.listen(3001)</del>

同样也可以使用express和koa的端口。

使用io.emit是广播，这是服务器广播。然而库还封装了客户的广播(实际上都是由客户端发起的)，就是服务器广播去掉发动广播的socket。亲测属实啊，精妙的框架！

同一端口上还可以有命名空间。

下面用以上关于socket.io的知识写一个web版本的多人聊天例子。

server代码

	// chat.js
	var fs = require("fs");
	
	var io = require("socket.io")(3001);
	
	var server = require("http").createServer(function(req ,res){
	
		fs.readFile(__dirname + "/chat.html" ,function(err ,data){
			if(err){
				res.writeHead(500);
				return res.end("error when loading chat.html");
			}
			res.writeHead(200);
			res.end(data);
		});
	
	})
	
	server.listen(3000);
	
	io.of("/chat").on("connection" ,function(socket){
	
		socket.on("new client message" ,function(data){
			socket.broadcast.emit("new server message" ,data);
		})
	
	})

client代码（chat.html）

	<!-- chat.html -->
	<!DOCTYPE html>
	<html>
	<head>`
		<meta charset="utf-8">
		<meta http-equiv="X-UA-Compatible" content="IE=edge">
		<title>chat</title>
		<script src="https://cdn.socket.io/socket.io-1.3.5.js"></script>
		<link rel="stylesheet" href="">
	</head>
	<body>
		<form id="chat" action="">
			<input id="chatContent" type="text" placeholder="input some word">
		</form>
		<ul id="chatList">
			
		</ul>
		<script>
	
		var name = prompt("what's your name") || "no name";
	
		var chat = io("http://localhost:3001/chat");
	
		var render = renderIt("chatList");
	
		chat.on("new server message" ,function(data){
			render(data);
		})
	
		document.getElementById("chat").onsubmit = function(e){
			var data = {
				name : name,
				content : document.getElementById("chatContent").value
			};
			chat.emit("new client message" ,data);
			render(data);
	
			e.preventDefault();
			return false;
		}
	
		function renderIt(ul){
			var ul = document.getElementById(ul);
			return function(data){
				var nameContent = document.createElement("b");
				var contentContent = document.createElement("span");
				var li = document.createElement("li");
	
				var name = document.createTextNode(data.name);
				var content = document.createTextNode("："+data.content);
	
				nameContent.appendChild(name);
				contentContent.appendChild(content);
	
				li.appendChild(nameContent);
				li.appendChild(contentContent);
	
				ul.appendChild(li);
			}
		}
	
		</script>
	</body>
	</html>

下面观察一下网络通信。刷新页面，客户端与服务器的三次握手。如下图。

![](http://i1.tietuku.com/4a9ffb2c870acf4f.png)

第一次握手是客户端申请发起链接请求，就是上图第一个请求，运行到var chat = io("http://localhost:3001/chat");一行时发送的，获得了一个sid。

第二次即为这次请求的返回，返回的主要内容为sid，表示已经收到客户端的请求。

第三次是上图的第二个HTTP请求，将sid捎带回去，表示客户端已经确认收到服务器的数据。

而上图中的第三个请求貌似返回一个命名空间的名字。我将命名空间去掉便没有了这一次请求。

最后还有这样一个通信。

![](http://i1.tietuku.com/1af82d8668c336fc.png)

我去了解了一下101这个状态码。

101 Switching Protocols

服务器已经理解了客户端的请求，并将通过Upgrade 消息头通知客户端采用不同的协议来完成这个请求。在发送完这个响应最后的空行后，服务器将会切换到在Upgrade 消息头中定义的那些协议。

只有在切换新的协议更有好处的时候才应该采取类似措施。例如，切换到新的HTTP 版本比旧版本更有优势，或者切换到一个实时且同步的协议以传送利用此类特性的资源。

反正就是切换协议了，此后所有的socket通信开发者工具是捕获不到的（开发者工具相当于是http过滤器，而socket走的是tcp，只是在链接的时候用到了http）。

当然细节已经被库封装好了，下面使用原生nodejs实现，探究一下里面的细节。

###原生nodejs实现

因为信息量巨大，所以作为一个主题后续更新。。。

##总结
