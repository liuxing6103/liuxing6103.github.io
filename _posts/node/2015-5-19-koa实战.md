---
layout: post
category: "node"
---

网上的大神水平都太高了，基本各种问题一笔带过，我是个小菜鸟，学习node不久，表示看太多大神的文这样并不能学好，这里我汇总并且科普一下各种中间件的作用。同时也是整理一个完善的网站应该有什么东西，以及需要有什么注意的地方。

#koa实战

如果不知道什么是中间件，请先学习express框架。这里简要的说一下。

中间件是node web编程中的概念，为什么会有中间件呢？当然是为了简化node web编程，同时中间件标准使得node插件开发有了共同的标准，所以各路大神开始对node web贡献自己的力量。

原生node的http服务器大概像这样的。

	require("http").createServer(function(req ,res){
	  res.writeHead(200 ,{"Content-Type" : "text/plain"});
	  red.end("hello world!");
	}).listen(4000);

createServer中的回调函数的两个变量分别是http request obj和http response obj。我们要做的事就是使用这两个对象搞一些事情，解析cookie头部，解析请求url的查询字符串，等等。如果都在这个函数里面搞就显得过于臃肿。所以大神们开始搞中间件框架，把各个功能模块分离开来。

node中常见的中间件框架如connect，express，与connect不同的是express中添加了很多实用的方法，然而从express版本变迁的特点来看，express正在把一些属于express对象的方法单独拿出来成为一个lib，这样避免了在不需要这些方法的时候使应用变得臃肿。koa同样属于中间件框架，koa使用了es6中的generator，而且koa的中间件跟express的中间件貌似不是共用的。这里就不说generator了，至于generator有多厉害，自行百度，或者我这里有一篇关于generator的文章。

下面开始介绍一下各种中间件。实际上就是记录一下查文档的所见。 

所有中间件的文档都在[npm的官网](https://www.npmjs.com/)上。

##基本主题

###koa-logger

没啥好说的，koa有原生的logger，use这个logger之后，log的内容可读性更强了。使用前后logger风格可是不一样的哦。

###koa-static-cache

koa的静态文件服务器。规定一个应用中的静态文件的地址。通常是一些web静态资源。

拿php来作对比，可以说node是偏底层的平台，本身可以生成http服务器，而php是依托于Apache服务器的，所以node用起来比较方便。关于Apache的静态配置方法我也不知道，没仔细研究过。

底层实现大概是对路径下的文件进行了读取操作（然而php隐藏了这些细节）。

###koa-route

web应用少了路由怎么活？

官网这样用。显而易见可以传参数，参数在control的参数列表里。相当爽是吧。。。

	var pets = {
	  list: function *(){
	    var names = Object.keys(db);
	    this.body = 'pets: ' + names.join(', ');
	  },
	 
	  show: function *(name){
	    var pet = db[name];
	    if (!pet) return this.throw('cannot find that pet', 404);
	    this.body = pet.name + ' is a ' + pet.species;
	  }
	};

	app.use(_.get('/pets', pets.list));
	app.use(_.get('/pets/:name', pets.show));

路由规则同样可以使用正则表达式。（下面是个带日期格式参数的请求）。

	app.use(route.get(/^\/blog\/\d{4}-\d{2}-\d{2}\/?$/i ,function*(){
	  this.body = this.path;
	}))

我并没有找到合适的方法拿到这个参数。暂且用this.path可以得到这部分信息。

最醉的是，为什么这个路由会失效？js命令行中明明就返回的true。原因是这个等价于blog后面加查询，而这种重复了会导致逻辑散乱。

	app.use(route.get(/^\/blog\/\?first=\w+&second=\w+\/?$/i ,function*(){
	  this.body = this.query;
	}))、

这个先到这里，功能也算够用了。

然而这并不能处理post请求的参数，post请求不经过url，要通过处理请求体来获得。这样又需要其他的中间件，如下。

###co-body/koa-body

从官网的下载量来看，koa-body明显占优的（co-body上周的下载量竟然是0，不科学啊最起码我还下载一次啊，可能隔周更新下载数？不算天朝码农下载？）。仔细一看原来koa-body是co-body的拓展，更确切的说co-body是koa-body的一个依赖。

普通的post请求（MIME：application/x-www-urlencoded）使用this.request.body就可以得到json。

上传文件的表单（MIME：multipart/form-data）用法如下。

	//注意配置multipart:true一定要有。
	//配置上传文件的路径。
	app.use(koaBody({
	  formidable:{uploadDir: __dirname},
	  multipart:true
	}));
	app.use(route.get("/",list));
	
	app.use(route.post("/",list));
	function *list(){
	  console.log(this.request.body.fields);
	  console.log(this.request.body.files);
	  this.body = "<form action='/' method='post' enctype='multipart/form-data'>\
	  <input name='name' />\
	  <input type='file' name='file'/>\
	  <input type='submit' value='submit' multiple='multiple'>\
	  </form>"
	}

Ajax的话，传入后台的参数同样可以用普通表单的方法，this.request.body，this.body作为Ajax的返回值。

至此路由以及通信ok了，下一步渲染页面。

###koa-ejs

渲染页面需要一种模板，这里选用ejs模板。

同样，还有jade版，swig版。中间件的名称可能会有细微的差别。

下面是配置。root就是模板的位置。layout，总的模板，通常就header，footer什么的。viewExt，layout的拓展名，注意引用其他模板时不写拓展名的时候，默认还是*.ejs。debug，开发的时候设置为true，你的ejs语法错误的时候会给提示，上线时调整到false。cache，是否缓存。filter，变量格式化。

注意layout这个，可以将layout设置为false使引擎抛弃layout的使用方法。

	var filters = {
	  format: function (time) {
	    return time.getFullYear() + '-' + (time.getMonth() + 1) + '-' + time.getDate();
	  }
	};
	
	render(app, {
	  root: path.join(__dirname, 'views'),
	  layout: 'template',
	  viewExt: 'html',
	  cache: false,
	  debug: true,
	  filters: filters
	});

render实质上还是是给this.body赋值。不过这些细节被render方法隐藏了。

	app.use(route.get("/",list));
	
	function *list(){
	
	  yield this.render("index",{title:"index page",time:new Date()});
	
	}

至于ejs具体怎么使用，看[这个](https://www.npmjs.com/package/ejs)吧，官方文档在Google code上，被墙了。顺便提一下，这样使用filter（神奇的npm文档里面没提- -）。

	<%=: time | format %>

现在的应用已经初具规模，下面讨论会话和数据的持久化。

##会话和存储

npm中的会话管理基本都是跟数据库挂钩的，这样减轻了内存的压力，而且当服务器宕机重启之后，你的session依然存在数据库中，是一种很好的做法。这里选用流行的非关系型数据库mongodb，使用一种mongodb的ORM，mongoose。

###mongoose

一种mongodb的对象建模工具。当使用Mongoose时，我们不在需要在数据库中创建好结构(Schema)之后，再与后端代码中创建的对象或类进行映射这样繁琐的操作。在Mongoose的封装下，我们只需定义好JSON类型的数据结构即可。

首先链接数据库，前提是mongodb服务已经运行。链接后返回一个数据库对象。
	
	// db.js
	
	var mongoose = require('mongoose');
	mongoose.connect('mongodb://localhost/test');
	
	module.exports = mongoose;

然后这里我建立一个简单的模式，也就是一个集合内元素的结构。

	// User.js
	
	var mongoose = require("./db");
	var userSchema = new mongoose.Schema({
		name : {type : String ,match : /^\w+$/},
		age : {type : Number ,min : 1},
		regTime : Date,
		pwd : String
	})
	
	var User = mongoose.model("User" ,userSchema);

有了这个就可以搞一些事情了。这里导出一组api，这里的api是es6的同步形式，用的还不是很熟练。如下。

	var co = require("co");
	
	var thunkify = require("thunkify");
	
	var save = thunkify(User.prototype.save);
	
	var find = thunkify(function(){User.find.apply(User ,arguments)});
	
	var findOne = thunkify(function(){User.findOne.apply(User ,arguments)});
	
	module.exports = {
		model : User ,
		addUser : function *(name ,age ,password){
			var newUser = new User({
				name : name ,
				age : age ,
				regTime : new Date() ,
				pwd : password
			});
			co(function*(){
				try{
					yield newUser.save();
				}catch(e){
					console.error(e);
				}
			});
		} ,
		thereIs : function *(name){
			return co(function*(){
				try{
					var user = yield find({name : name});
					return !!user.length;
				}catch(e){
					console.error(e);
				}
			})
		} ,
		pwdRight : function *(name ,password){
			return co(function*(){
				try{
					var user = yield findOne({name : name});
					return user.pwd == password;
				}catch(e){
					console.error(e);
				}
			})
		}
	};


通过语义可以判断这是一组注册登陆的数据库api，功能有，添加用户，验证用户名是否存在，检查秘密是否正确。然后在路由中编写逻辑（逻辑就比较简单了，不必细看了）。

	// index.js
	var User = require("../models/User");
	
	module.exports = {
		reg : function *(){
	
			var params = this.request.body;
			var userName = params.name;
	
			if(!(yield User.thereIs(userName))){
				yield User.addUser(userName ,params.age ,params.password);
	
				this.redirect("/");
			}else{
				this.redirect("/reg");
			}
		},
		login : function *(){
	
			var params  = this.request.body;
			var userName = params.name;
	
			if(yield User.pwdRight(userName ,params.password)){
				this.redirect("/");
			}else{
				this.redirect("/login");
			}
		},
		logout : function *(){
			this.redirect("/login");
		},
		regRender : function *(){
			yield this.render("reg" ,{title : "用户注册"});
		},
		loginRender : function *(){
			yield this.render("login" ,{title : "用户登录"});
		},
		mainRender : function *(){
			yield this.render("main" ,{});
		}
	}

###koa-session-store&koa-session-mongoose

用法就是这样简单，然后ctx.request.session就可以用了，并且会储存在mongodb里面。

	var session = require('koa-session-store');

	var mongooseStore = require('koa-session-mongoose');
	
	app.keys = ['some secret key'];
	
	app.use(session({
	  store: mongooseStore.create()
	}));

带有session的注册登陆逻辑如下。

	// index.js
	var User = require("../models/User");
	
	var session = require("../functions/session");
	
	module.exports = {
		reg : function *(){
	
			var params = this.request.body;
			var userName = params.name;
	
			if(!(yield User.thereIs(userName))){
				yield User.addUser(userName ,params.age ,params.password);
	
				session.saveSession(this ,userName);
				this.redirect("/");
			}else{
				this.redirect("/reg");
			}
		},
		login : function *(){
	
			var params  = this.request.body;
			var userName = params.name;
	
			if(yield User.pwdRight(userName ,params.password)){
				session.saveSession(this ,userName);
				this.redirect("/");
			}else{
				this.redirect("/login");
			}
		},
		logout : function *(){
			session.deleteSession(this);
			this.redirect("/login");
		},
		regRender : function *(){
			yield this.render("reg" ,{title : "用户注册"});
		},
		loginRender : function *(){
			yield this.render("login" ,{title : "用户登录"});
		},
		mainRender : function *(){
			if(session.userLogined(this)){
				yield this.render("main" ,{userName :this.session.userName});
			}else{
				this.redirect("/login");
			}
		}
	}

##web前端攻击的防范

主要预防xss攻击和csrf攻击，关于xss和csrf攻击这里不多说。

###xss

一个xss过滤器，这不是个中间件，是个函数，过滤你想过滤的String。

	var xss = require('xss');
	var html = xss('<script>alert("xss");</script>');
	console.log(html);

###koa-csrf

来自官网的例子。

	var koa = require('koa')
	var csrf = require('koa-csrf')
	var session = require('koa-session')
	 
	var app = koa()
	app.keys = ['session secret']
	app.use(session())
	csrf(app)
	app.use(csrf.middleware)
	 
	app.use(function* () {
	  if (this.method === 'GET') {
	    this.body = this.csrf
	  } else if (this.method === 'POST') {
	    this.status = 204
	  }
	})

csrf(app)为这次会话取得一个特定的csrf taken。csrf.middleware是官方提供的一个csrf拦截器，可以自定义拦截器。

当我按照上面的官方例子书写的时候，程序出现了异常。显示需要ctx.session.secret，所以我就定义了一个secret果然就不报错了。我的代码如下。

	//csrf字段生成
	app.use(function*(next){
	  this.session.secret = "shaomingquan";
	  yield next;
	})
	csrf(app);
	
	//csrf拦截器初始化
	var csrfIntercept = require("./functions/csrfIntercept");
	app.use(csrfIntercept);

csrf拦截器如下。

	module.exports = function *(next){
		if(this.method === "GET"){
			yield next;
		}else{
			try{
				console.log(this.request.body);
				console.log(this.csrf);
				this.assertCSRF(this.request.body);
				yield next;
			}catch(e){
				this.status = 403;
				this.body = "trying csrf?";
				return ;
			}
		}
	}

###crypto

一个加密库。密码等用户的重要信息不可明文存放，要对这些信息进行加密。加密可以在客户端进行，这也是个不错的选择（还记得一年半之前做第一个项目，老大就是让我前台加密）。

到此为止似乎网站已经相对安全，加上前面的一套东西，已经可以做一些基本的东西了。当然，网站开发不止这些东西，还有许多主题，比如实时通讯，搜索引擎架构，权限控制，邮件优先队列，日志记录分析（当我跟同窗的Java服务器谈论后端开发的时候他说了诸如以上主题）。

##单元测试

虽然这个跟koa并没有什么关系。但是测试很重要，这里也总结一下在node里面做测试的方法。比如在前后端分离开发的时候，后端接口无法通过前台直接调试，所以验证接口拿到单元测试里面。

还有就是有时候采用TDD或者BDD开发模式也需要这些单元测试框架的支持。
关于这些知识参见[这里](http://www.cnblogs.com/wangshenhe/archive/2013/02/16/2913431.html)。

因为测试需要，有时候一些面向过程的函数也需要返回true or false。

现在用之前写好的登陆注册模块开始写测试代码。注意测试框架一般要在全局环境安装，因为要在系统环境新增命令（就像nodeunit，mocha），工程环境不必安装。

###nodeunit

经典的xUnit系列的单元测试模式。比较简单，api也很简单。nodeunit可以单独使用也可以作为grunt的一个插件来使用。

可作为TDD驱动工具。

上官网例子（[官网传送门](https://www.npmjs.com/package/nodeunit)）。

	exports.testSomething = function(test){
	    test.expect(1);
	    test.ok(true, "this assertion should pass");
	    test.done();
	};
	
	exports.testSomethingElse = function(test){
	    test.ok(false, "this assertion should fail");
	    test.done();
	};

运行结果

![](https://github.com/caolan/nodeunit/raw/master/img/example_fail.png)

再看看我这里面的测试，测试内容是index.js这个路由，注意测试之前将服务器跑起来。这里用到辅助的模块request。

我把我的登陆注册的post接口测试了一下，估计现在数据库各种用户。。。

	// routesIndex.js
	
	var request = require("request");
	
	var uuid = require("uuid");
	
	var Promise = require("promise");
	
	var fWriter = require("fs").writeFile;
	
	var protocal = "http"
	
	var host = "localhost";
	
	var port = 3000;
	
	var url = [[protocal,host].join("://"),port].join(":");
	
	exports.reg = function(test){
		//user exist
	
	
		var badReg = new Promise(function(resolve ,reject){
	
			request.post({
				url : url + "/reg" ,
				form : {
					name : "111",
					age : "111",
					password : "111",
					_csrf : "ok"
				}
			} ,function(err ,httpResponse ,body){
				test.ok(httpResponse.statusCode == 200 ,"bad user name should not success");
				resolve();
			});
		})
	
	
		var goodReg = new Promise(function(resolve ,reject){
	
			//user not exsit. ok!
			request.post({
				url : url + "/reg" ,
				form : {
					name : uuid.v1(),
					age : "111",
					password : "111",
					_csrf : "ok"
				}
			} ,function(err ,httpResponse ,body){
				test.ok(httpResponse.statusCode == 302 ,"good user should success");
				resolve();
			});
			
		})
	
		Promise.all([badReg ,goodReg]).then(function(){
			test.done();
		})
	
	
	};
	exports.login = function(test){
	
		test.expect(3);
	
		var noCsrf = new Promise(function(resolve ,reject){
	
			request.post({
				url : url + "/login" ,
				form : {
					name : "111",
					password : "222"
				}
			} ,function(err ,httpResponse ,body){
				test.ok(httpResponse.statusCode == 403 ,"should have field _csrf");
				resolve();
			})
	
		})
		
		var badLogin = new Promise(function(resolve ,reject){
	
			request.post({
				url : url + "/login" ,
				form : {
					name : "111",
					password : "222",
					_csrf : "ok"
				}
			} ,function(err ,httpResponse ,body){
				test.ok(httpResponse.statusCode == 200 ,"badLogin should not jump to main page");
				resolve();
			})
	
		})
	
		var goodLogin = new Promise(function(resolve ,reject){
	
			request.post({
				url : url + "/login" ,
				form : {
					name : "111" ,
					password : "111",
					_csrf : "ok"
				}
			} ,function(err ,httpResponse ,body){
				test.ok(httpResponse.statusCode == 302 ,"goodLogin should jump to main page");
				resolve();
			})
	
		})
	
		Promise.all([noCsrf ,badLogin ,goodLogin]).then(function(){
			test.done();
		})
	
	}

两个模块，reg两个测试，一个用户存在的测试，用户不存在顺利注册的测试。

login三个测试，不发_csrf不可以使用接口，密码错误，密码正确。

每个模块有几个异步的方法，所以用到promise的all方法，这里就不多说了。

我改了刷新的方式，不再用redirect，换作前端刷新，这样可以区别响应码（一个302，一个200）。如果有更好的方法一定要告诉我。。。

###mocha

这个测试工具的下载量已经是nodeunit的十倍以上了。所以算是现在比较主流的node测试框架。

mocha作为行为驱动测试框架，本身思想上要先进于nodeunit。可以比较容易的进行文学式的编程。

可以自选assert库，原生assert或者shuold或者except等等。这里我们使用should。

	// routesIndex.js
	var should = require("should");
	
	var request = require("request");
	
	var uuid = require("uuid");
	
	var protocal = "http";
	
	var host = "localhost";
	
	var port = "3000";
	
	var root = [[protocal ,host].join("://") ,port].join(":");
	
	describe("reg" ,function(){
		it("badReg should not pass" ,function(){
			request.post({
				url : root + "/reg",
				form : {
					name : "111" ,
					age : "11" ,
					password : "111",
					_csrf : "ok"
				}
			} ,function(err ,httpRes ,body){
	
				httpRes.should.have.property("statusCode" ,200);
	
			})
		});
	
		it("goodReg should pass" ,function(){
			request.post({
				url : root + "/reg" ,
				form : {
					name : uuid.v1() ,
					age : "11" ,
					password : "111",
					_csrf : "ok"
				}
			} ,function(err ,httpRes ,body){
	
				httpRes.should.have.property("statusCode" ,302);
	
			})
		})
	});
	
	describe("login" ,function(){
		it("without csrf field should return 403" ,function(){
			request.post({
				url : root + "/login" ,
				form : {
					name : "111" ,
					password : "111"
				}
			} ,function(err ,httpRes ,body){
	
				httpRes.should.have.property("statusCode" ,403);
	
			})
		})
	
		it("badLogin should not pass" ,function(){
			request.post({
				url : root + "/login" ,
				form : {
					name : "11111111",
					password : "wrong",
					_csrf : "ok"
				}
			} ,function(err ,httpRes ,body){
	
				httpRes.should.have.property("statusCode" ,200);
	
			})
		})
	
		it("goodLogin should pass" ,function(){
			request.post({
				url : root + "/login" ,
				form : {
					name : "111" ,
					password : "111",
					_csrf : "ok"
				}
			} ,function(err ,httpRes ,body){
	
				httpRes.should.have.property("statusCode" ,302);
	
			})
		})
	})

上个图。两个模块五个测试完成之后是这样的。

![](http://i1.tietuku.com/609a783c408a2218.png)

##调试

同样跟koa并没有什么关系。

###node-inspector

同样要在全局环境下安装，安装详见npmjs.com。

##其他主题

敬请期待。。。